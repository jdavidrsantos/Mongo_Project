{"ast":null,"code":"// flow scored from vue select thanks Jeff!\n\nexport default {\n  watch: {\n    pointer: function pointer() {\n      this.maybeAdjustScroll();\n    }\n  },\n  data: function data() {\n    return {\n      pointer: -1\n    };\n  },\n  methods: {\n    /**\n     * Adjust the scroll position of the dropdown list\n     * if the current pointer is outside of the\n     * overflow bounds.\n     * @returns {*}\n     */\n    maybeAdjustScroll: function maybeAdjustScroll() {\n      var pixelsToPointerTop = this.pixelsToPointerTop();\n      var pixelsToPointerBottom = this.pixelsToPointerBottom();\n      if (pixelsToPointerTop <= this.viewport().top) {\n        return this.scrollTo(pixelsToPointerTop);\n      } else if (pixelsToPointerBottom >= this.viewport().bottom) {\n        return this.scrollTo(this.viewport().top + this.pointerHeight());\n      }\n    },\n    /**\n     * The distance in pixels from the top of the dropdown\n     * list to the top of the current pointer element.\n     * @returns {number}\n     */\n    pixelsToPointerTop: function pixelsToPointerTop() {\n      var pixelsToPointerTop = 0;\n      if (!this.$refs.options) {\n        return 0;\n      }\n      for (var i = 0; i < this.pointer; i++) {\n        pixelsToPointerTop += this.$refs.options.children[i].offsetHeight;\n      }\n      return pixelsToPointerTop;\n    },\n    /**\n     * The distance in pixels from the top of the dropdown\n     * list to the bottom of the current pointer element.\n     * @returns {*}\n     */\n    pixelsToPointerBottom: function pixelsToPointerBottom() {\n      return this.pixelsToPointerTop() + this.pointerHeight();\n    },\n    /**\n     * The offsetHeight of the current pointer element.\n     * @returns {number}\n     */\n    pointerHeight: function pointerHeight() {\n      var element = this.$refs.options ? this.$refs.options.children[this.pointer] : false;\n      return element ? element.offsetHeight : 0;\n    },\n    /**\n     * The currently viewable portion of the options.\n     * @returns {{top: (string|*|number), bottom: *}}\n     */\n    viewport: function viewport() {\n      return {\n        top: this.$refs.options ? this.$refs.options.scrollTop : 0,\n        bottom: this.$refs.options ? this.$refs.options.offsetHeight + this.$refs.options.scrollTop : 0\n      };\n    },\n    /**\n     * Scroll the options to a given position.\n     * @param position\n     * @returns {*}\n     */\n    scrollTo: function scrollTo(position) {\n      return this.$refs.options ? this.$refs.options.scrollTop = position : null;\n    }\n  }\n};","map":{"version":3,"names":["watch","pointer","maybeAdjustScroll","data","methods","pixelsToPointerTop","pixelsToPointerBottom","viewport","top","scrollTo","bottom","pointerHeight","$refs","options","i","children","offsetHeight","element","scrollTop","position"],"sources":["/Users/davidsantos/Documents/ilercon/Users/node_modules/vue-single-select/dist/pointerScroll.js"],"sourcesContent":["// flow scored from vue select thanks Jeff!\n\nexport default  {\n    watch: {\n      pointer() {\n        this.maybeAdjustScroll()\n      }\n    },\n    data() {\n        return {\n            pointer: -1\n        } \n    },\n    methods: {\n      /**\n       * Adjust the scroll position of the dropdown list\n       * if the current pointer is outside of the\n       * overflow bounds.\n       * @returns {*}\n       */\n      maybeAdjustScroll () {\n        let pixelsToPointerTop = this.pixelsToPointerTop()\n        let pixelsToPointerBottom = this.pixelsToPointerBottom()\n  \n        if ( pixelsToPointerTop <= this.viewport().top) {\n          return this.scrollTo( pixelsToPointerTop )\n        } else if (pixelsToPointerBottom >= this.viewport().bottom) {\n          return this.scrollTo( this.viewport().top + this.pointerHeight() )\n        }\n      },\n  \n      /**\n       * The distance in pixels from the top of the dropdown\n       * list to the top of the current pointer element.\n       * @returns {number}\n       */\n      pixelsToPointerTop() {\n        let pixelsToPointerTop = 0\n        if( !this.$refs.options ) {\n            return 0;\n        }\n\n        for (let i = 0; i < this.pointer; i++) {\n            pixelsToPointerTop += this.$refs.options.children[i].offsetHeight\n        }\n        \n        return pixelsToPointerTop\n      },\n  \n      /**\n       * The distance in pixels from the top of the dropdown\n       * list to the bottom of the current pointer element.\n       * @returns {*}\n       */\n      pixelsToPointerBottom() {\n        return this.pixelsToPointerTop() + this.pointerHeight()\n      },\n  \n      /**\n       * The offsetHeight of the current pointer element.\n       * @returns {number}\n       */\n      pointerHeight() {\n        let element = this.$refs.options ? this.$refs.options.children[this.pointer] : false\n        return element ? element.offsetHeight : 0\n      },\n  \n      /**\n       * The currently viewable portion of the options.\n       * @returns {{top: (string|*|number), bottom: *}}\n       */\n      viewport() {\n        return {\n          top: this.$refs.options ? this.$refs.options.scrollTop: 0,\n          bottom: this.$refs.options ? this.$refs.options.offsetHeight + this.$refs.options.scrollTop : 0\n        }\n      },\n  \n      /**\n       * Scroll the options to a given position.\n       * @param position\n       * @returns {*}\n       */\n      scrollTo(position) {\n        return this.$refs.options ? this.$refs.options.scrollTop = position : null\n      },\n    }\n  }\n"],"mappings":"AAAA;;AAEA,eAAgB;EACZA,KAAK,EAAE;IACLC,OAAO,qBAAG;MACR,IAAI,CAACC,iBAAiB,EAAE;IAC1B;EACF,CAAC;EACDC,IAAI,kBAAG;IACH,OAAO;MACHF,OAAO,EAAE,CAAC;IACd,CAAC;EACL,CAAC;EACDG,OAAO,EAAE;IACP;AACN;AACA;AACA;AACA;AACA;IACMF,iBAAiB,+BAAI;MACnB,IAAIG,kBAAkB,GAAG,IAAI,CAACA,kBAAkB,EAAE;MAClD,IAAIC,qBAAqB,GAAG,IAAI,CAACA,qBAAqB,EAAE;MAExD,IAAKD,kBAAkB,IAAI,IAAI,CAACE,QAAQ,EAAE,CAACC,GAAG,EAAE;QAC9C,OAAO,IAAI,CAACC,QAAQ,CAAEJ,kBAAkB,CAAE;MAC5C,CAAC,MAAM,IAAIC,qBAAqB,IAAI,IAAI,CAACC,QAAQ,EAAE,CAACG,MAAM,EAAE;QAC1D,OAAO,IAAI,CAACD,QAAQ,CAAE,IAAI,CAACF,QAAQ,EAAE,CAACC,GAAG,GAAG,IAAI,CAACG,aAAa,EAAE,CAAE;MACpE;IACF,CAAC;IAED;AACN;AACA;AACA;AACA;IACMN,kBAAkB,gCAAG;MACnB,IAAIA,kBAAkB,GAAG,CAAC;MAC1B,IAAI,CAAC,IAAI,CAACO,KAAK,CAACC,OAAO,EAAG;QACtB,OAAO,CAAC;MACZ;MAEA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACb,OAAO,EAAEa,CAAC,EAAE,EAAE;QACnCT,kBAAkB,IAAI,IAAI,CAACO,KAAK,CAACC,OAAO,CAACE,QAAQ,CAACD,CAAC,CAAC,CAACE,YAAY;MACrE;MAEA,OAAOX,kBAAkB;IAC3B,CAAC;IAED;AACN;AACA;AACA;AACA;IACMC,qBAAqB,mCAAG;MACtB,OAAO,IAAI,CAACD,kBAAkB,EAAE,GAAG,IAAI,CAACM,aAAa,EAAE;IACzD,CAAC;IAED;AACN;AACA;AACA;IACMA,aAAa,2BAAG;MACd,IAAIM,OAAO,GAAG,IAAI,CAACL,KAAK,CAACC,OAAO,GAAG,IAAI,CAACD,KAAK,CAACC,OAAO,CAACE,QAAQ,CAAC,IAAI,CAACd,OAAO,CAAC,GAAG,KAAK;MACpF,OAAOgB,OAAO,GAAGA,OAAO,CAACD,YAAY,GAAG,CAAC;IAC3C,CAAC;IAED;AACN;AACA;AACA;IACMT,QAAQ,sBAAG;MACT,OAAO;QACLC,GAAG,EAAE,IAAI,CAACI,KAAK,CAACC,OAAO,GAAG,IAAI,CAACD,KAAK,CAACC,OAAO,CAACK,SAAS,GAAE,CAAC;QACzDR,MAAM,EAAE,IAAI,CAACE,KAAK,CAACC,OAAO,GAAG,IAAI,CAACD,KAAK,CAACC,OAAO,CAACG,YAAY,GAAG,IAAI,CAACJ,KAAK,CAACC,OAAO,CAACK,SAAS,GAAG;MAChG,CAAC;IACH,CAAC;IAED;AACN;AACA;AACA;AACA;IACMT,QAAQ,oBAACU,QAAQ,EAAE;MACjB,OAAO,IAAI,CAACP,KAAK,CAACC,OAAO,GAAG,IAAI,CAACD,KAAK,CAACC,OAAO,CAACK,SAAS,GAAGC,QAAQ,GAAG,IAAI;IAC5E;EACF;AACF,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}