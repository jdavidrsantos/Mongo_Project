{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/davidsantos/Documents/ilercon/Users/node_modules/@babel/runtime/helpers/slicedToArray.js\")[\"default\"];\nvar _createForOfIteratorHelper = require(\"/Users/davidsantos/Documents/ilercon/Users/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\")[\"default\"];\nrequire(\"core-js/modules/es.object.define-property.js\");\nrequire(\"core-js/modules/es.function.name.js\");\nrequire(\"core-js/modules/es.array.concat.js\");\nrequire(\"core-js/modules/es.map.js\");\nrequire(\"core-js/modules/es.object.to-string.js\");\nrequire(\"core-js/modules/es.string.iterator.js\");\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\nrequire(\"core-js/modules/es.set.js\");\nrequire(\"core-js/modules/es.array.index-of.js\");\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = removeTypeDuplicates;\nvar _generated = require(\"../../validators/generated\");\nfunction getQualifiedName(node) {\n  return (0, _generated.isIdentifier)(node) ? node.name : \"\".concat(node.id.name, \".\").concat(getQualifiedName(node.qualification));\n}\nfunction removeTypeDuplicates(nodes) {\n  var generics = new Map();\n  var bases = new Map();\n  var typeGroups = new Set();\n  var types = [];\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    if (!node) continue;\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n    if ((0, _generated.isAnyTypeAnnotation)(node)) {\n      return [node];\n    }\n    if ((0, _generated.isFlowBaseAnnotation)(node)) {\n      bases.set(node.type, node);\n      continue;\n    }\n    if ((0, _generated.isUnionTypeAnnotation)(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes = nodes.concat(node.types);\n        typeGroups.add(node.types);\n      }\n      continue;\n    }\n    if ((0, _generated.isGenericTypeAnnotation)(node)) {\n      var name = getQualifiedName(node.id);\n      if (generics.has(name)) {\n        var existing = generics.get(name);\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics.set(name, node);\n      }\n      continue;\n    }\n    types.push(node);\n  }\n  var _iterator = _createForOfIteratorHelper(bases),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n        baseType = _step$value[1];\n      types.push(baseType);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var _iterator2 = _createForOfIteratorHelper(generics),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _slicedToArray(_step2.value, 2),\n        genericName = _step2$value[1];\n      types.push(genericName);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return types;\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;AAAA;AASA,SAASA,gBAAgB,CAACC,IAAmC,EAAU;EACrE,OAAO,2BAAY,EAACA,IAAI,CAAC,GACrBA,IAAI,CAACC,IAAI,aACND,IAAI,CAACE,EAAE,CAACD,IAAK,cAAGF,gBAAgB,CAACC,IAAI,CAACG,aAAa,CAAE,CAAC;AAC/D;AAKe,SAASC,oBAAoB,CAE1CC,KAA2D,EAC7C;EACd,IAAMC,QAAQ,GAAG,IAAIC,GAAG,EAAmC;EAC3D,IAAMC,KAAK,GAAG,IAAID,GAAG,EAAsD;EAG3E,IAAME,UAAU,GAAG,IAAIC,GAAG,EAAgB;EAE1C,IAAMC,KAAmB,GAAG,EAAE;EAE9B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,KAAK,CAACQ,MAAM,EAAED,CAAC,EAAE,EAAE;IACrC,IAAMZ,IAAI,GAAGK,KAAK,CAACO,CAAC,CAAC;IACrB,IAAI,CAACZ,IAAI,EAAE;IAGX,IAAIW,KAAK,CAACG,OAAO,CAACd,IAAI,CAAC,IAAI,CAAC,EAAE;MAC5B;IACF;IAGA,IAAI,kCAAmB,EAACA,IAAI,CAAC,EAAE;MAC7B,OAAO,CAACA,IAAI,CAAC;IACf;IAEA,IAAI,mCAAoB,EAACA,IAAI,CAAC,EAAE;MAC9BQ,KAAK,CAACO,GAAG,CAACf,IAAI,CAACgB,IAAI,EAAEhB,IAAI,CAAC;MAC1B;IACF;IAEA,IAAI,oCAAqB,EAACA,IAAI,CAAC,EAAE;MAC/B,IAAI,CAACS,UAAU,CAACQ,GAAG,CAACjB,IAAI,CAACW,KAAK,CAAC,EAAE;QAE/BN,KAAK,GAAGA,KAAK,CAACa,MAAM,CAAClB,IAAI,CAACW,KAAK,CAAC;QAChCF,UAAU,CAACU,GAAG,CAACnB,IAAI,CAACW,KAAK,CAAC;MAC5B;MACA;IACF;IAGA,IAAI,sCAAuB,EAACX,IAAI,CAAC,EAAE;MACjC,IAAMC,IAAI,GAAGF,gBAAgB,CAACC,IAAI,CAACE,EAAE,CAAC;MAEtC,IAAII,QAAQ,CAACW,GAAG,CAAChB,IAAI,CAAC,EAAE;QACtB,IAAImB,QAAgB,GAAGd,QAAQ,CAACe,GAAG,CAACpB,IAAI,CAAC;QACzC,IAAImB,QAAQ,CAACE,cAAc,EAAE;UAC3B,IAAItB,IAAI,CAACsB,cAAc,EAAE;YACvBF,QAAQ,CAACE,cAAc,CAACC,MAAM,GAAGnB,oBAAoB,CACnDgB,QAAQ,CAACE,cAAc,CAACC,MAAM,CAACL,MAAM,CAAClB,IAAI,CAACsB,cAAc,CAACC,MAAM,CAAC,CAClE;UACH;QACF,CAAC,MAAM;UACLH,QAAQ,GAAGpB,IAAI,CAACsB,cAAc;QAChC;MACF,CAAC,MAAM;QACLhB,QAAQ,CAACS,GAAG,CAACd,IAAI,EAAED,IAAI,CAAC;MAC1B;MAEA;IACF;IAEAW,KAAK,CAACa,IAAI,CAACxB,IAAI,CAAC;EAClB;EAAA,2CAG2BQ,KAAK;IAAA;EAAA;IAAhC,oDAAkC;MAAA;QAApBiB,QAAQ;MACpBd,KAAK,CAACa,IAAI,CAACC,QAAQ,CAAC;IACtB;EAAA;IAAA;EAAA;IAAA;EAAA;EAAA,4CAG8BnB,QAAQ;IAAA;EAAA;IAAtC,uDAAwC;MAAA;QAA1BoB,WAAW;MACvBf,KAAK,CAACa,IAAI,CAACE,WAAW,CAAC;IACzB;EAAA;IAAA;EAAA;IAAA;EAAA;EAEA,OAAOf,KAAK;AACd","names":["getQualifiedName","node","name","id","qualification","removeTypeDuplicates","nodes","generics","Map","bases","typeGroups","Set","types","i","length","indexOf","set","type","has","concat","add","existing","get","typeParameters","params","push","baseType","genericName"],"sources":["../../../src/modifications/flow/removeTypeDuplicates.ts"],"sourcesContent":["import {\n  isAnyTypeAnnotation,\n  isGenericTypeAnnotation,\n  isUnionTypeAnnotation,\n  isFlowBaseAnnotation,\n  isIdentifier,\n} from \"../../validators/generated\";\nimport type * as t from \"../..\";\n\nfunction getQualifiedName(node: t.GenericTypeAnnotation[\"id\"]): string {\n  return isIdentifier(node)\n    ? node.name\n    : `${node.id.name}.${getQualifiedName(node.qualification)}`;\n}\n\n/**\n * Dedupe type annotations.\n */\nexport default function removeTypeDuplicates(\n  // todo(babel-8): change type to Array<...>\n  nodes: ReadonlyArray<t.FlowType | false | null | undefined>,\n): t.FlowType[] {\n  const generics = new Map<string, t.GenericTypeAnnotation>();\n  const bases = new Map<t.FlowBaseAnnotation[\"type\"], t.FlowBaseAnnotation>();\n\n  // store union type groups to circular references\n  const typeGroups = new Set<t.FlowType[]>();\n\n  const types: t.FlowType[] = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n\n    // detect duplicates\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n\n    // this type matches anything\n    if (isAnyTypeAnnotation(node)) {\n      return [node];\n    }\n\n    if (isFlowBaseAnnotation(node)) {\n      bases.set(node.type, node);\n      continue;\n    }\n\n    if (isUnionTypeAnnotation(node)) {\n      if (!typeGroups.has(node.types)) {\n        // todo(babel-8): use .push when nodes is mutable\n        nodes = nodes.concat(node.types);\n        typeGroups.add(node.types);\n      }\n      continue;\n    }\n\n    // find a matching generic type and merge and deduplicate the type parameters\n    if (isGenericTypeAnnotation(node)) {\n      const name = getQualifiedName(node.id);\n\n      if (generics.has(name)) {\n        let existing: t.Flow = generics.get(name);\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params = removeTypeDuplicates(\n              existing.typeParameters.params.concat(node.typeParameters.params),\n            );\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics.set(name, node);\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  // add back in bases\n  for (const [, baseType] of bases) {\n    types.push(baseType);\n  }\n\n  // add back in generics\n  for (const [, genericName] of generics) {\n    types.push(genericName);\n  }\n\n  return types;\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}